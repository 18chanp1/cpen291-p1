# student name: Paco Chan
# student number: 82033788
import random
import adafruit_matrixkeypad
from mylcd import *

class TicTacToe:
    def __init__(self, lcdDisplay: myLCD, inpad:adafruit_matrixkeypad): # Use as is
        """ initializes data fields (board and played)
            and prints the banner messages
            and prints the initial board on the screen
        """
        self.board = [' '] * 9 # A list of 9 strings, one for each cell,
                               # will contain ' ' or 'X' or 'O'
        self.played = set()    # Set (of cell num) already played: to keep track of the played cells
        self.display = lcdDisplay
        self.keypad = inpad
        self.boardPrinted = False
        self.display.refresh()
        self.display.displayText("Tic-Tac-Toe! \n", 0xffffff, 5,5)
        self.printBoard()
        self.boardPrinted = False

    def printBoard(self) -> None:
        """ prints the board on the screen based on the values in the self.board data field """
        if(self.boardPrinted):
            self.display.popElement
        

        r1c1 = f"   {self.board[0]} | {self.board[1]} | {self.board[2]}\n"    # prints first row of game board
        r1c2 = ""                                                     # prints board labels on first row
        r2 = "   --+---+--\n"                                          # prints the row separators in board

        r3c1 = f"   {self.board[3]} | {self.board[4]} | {self.board[5]}\n"   # prints second row of game board
        r3c2 = ""                                                  # prints board labels on second row
        r4 = "   --+---+--\n"                                          # prints row separators

        r5c1 = f"   {self.board[6]} | {self.board[7]} | {self.board[8]}\n"   # prints third row of game board
        r5c2 = ""                                                    # prints board labels on third row

        self.display.displayText(r1c1 + r1c2 + r2 + r3c1 + r3c2 + r4 + r5c1 + r5c2, 0xffffff, 5, 25)
        self.boardPrinted = True

    def playerNextMove(self) -> None:
        """ prompts the player for a valid cell number;
            error checks that the input is a valid cell number;
            and prints the info and the updated self.board;
        """
        validInput = False             # set valid to false so user will be prompted on first run
        displayedWarning = False
        time.sleep(1)



        while not validInput:       # keep prompting while input is invalid               # check that input is an integer - no exceptions when casting.
            while True:
                if self.keypad.pressed_keys:
                    move = self.keypad.pressed_keys[0] - 1
                    break
            
            if self.played.__contains__(move):
                if not displayedWarning:
                    self.display.displayText("Box taken idiot", 0xfffff0, 5, 110)
                    displayedWarning = True
                time.sleep(0.3)
                
            else: 
                if displayedWarning:
                    self.display.popElement()
                self.display.popElement()
                self.board[move] = 'X'
                self.played.add(move)
                self.printBoard()
                validInput = True


    def computerNextMove(self) -> None:
        """ computer randomly chooses a valid cell,
            and prints the info and the updated self.board
        """
        valid = False                                   # valid is false so computer can generate random cell on board

        while not(valid):                             # keep generating random cells from 0-8 until generated cell
            move = random.randint(0, 8)                 # is not taken

            if not (self.played.__contains__(move)):  # if random cell selected has not been used, computer chooses
                self.played.add(move)
                self.board[move] = 'O'
                self.printBoard()
                valid = True                            # move is valid and exit loop
            else:
                continue                                # keep looping until valid move is generated by random int
                                                        # selector

    def hasWon(self, who: str) -> bool:
        """ returns True if who (being passed 'X' or 'O') has won, False otherwise """
        whoWins = False         # set self as not won as default

        # check whether self wins by vertical columns, and set selfWon to true if who won.
        for x in range(3):
            if self.board[x] == who and self.board[x+3] == who and self.board[x+6] == who:
                whoWins = True
        # check whether self wins by horizontal rows and set selfWon to true if who won.
        for y in range(0, 9, 3):
            if self.board[y] == who and self.board[y+1] == who and self.board[y+2] == who:
                whoWins = True
        # check whether self wins by diagonals and set selfWon to true if who won.
        if self.board[0] == who and self.board[4] == who and self.board[8] == who:
            whoWins = True
        if self.board[2] == who and self.board[4] == who and self.board[6] == who:
            whoWins = True

        # return true if any of the win conditions are satisfied above. Otherwise, returns false
        return whoWins

    def terminate(self, who: str) -> bool:
        """ returns True if who (being passed 'X' or 'O') has won or if it's a draw, False otherwise;
            it also prints the final messages:
                 "You won! Thanks for playing." or
                 "You lost! Thanks for playing." or
                 "A draw! Thanks for playing."
        """

        # determines whether board is completely full. Returns true if completely full. False otherwise.
        allFilled = True
        for i in range(0,9):
            if self.board[i] == ' ':
                allFilled = False

        # if board is full and no one has the winning condition, set tie to true. Otherwise, false.
        tie = not(self.hasWon('X')) and not(self.hasWon('O')) and allFilled

        # prints corresponding message based on players/computer winning condition and spec.
        if tie:
            self.display.displayText("A draw!", 0xfffff, 10, 110)
            return True    # returns true for a tie

        if self.hasWon('X'):
            self.display.displayText("You won! ", 0xfffff, 10, 110)
        elif self.hasWon('O'):
            self.display.displayText("You lost!", 0xfffff, 10, 110)

        # returns value depending on whether "who" wins or not based on spec.
        if self.hasWon(who):
            return True
        else:
            return False
    


if __name__ == "__main__":  # Use as is
    ttt = TicTacToe()  # initialize a game
    while True:
        ttt.playerNextMove()            # X starts first
        if(ttt.terminate('X')): break   # if X won or a draw, print message and terminate
        ttt.computerNextMove()          # computer plays O
        if(ttt.terminate('O')): break   # if O won or a draw, print message and terminate